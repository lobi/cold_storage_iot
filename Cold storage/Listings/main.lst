C51 COMPILER V9.60.7.0   MAIN                                                              10/16/2024 14:08:23 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h> 
   2          //#include <reg51.h>
   3          //#include <REGX51.H>
   4          
   5          #include <stdio.h>
   6          #include <string.h>
   7          #include <stdlib.h>
   8          
   9          #include "utils.h"
  10          #include "delay.h"
  11          #include "I2C.h"
  12          #include "eeprom.h"
  13          #include "LCD8bit.h"
  14          sbit LED1 = P1 ^ 6;
  15          sbit LED2 = P1 ^ 5;
  16          #include "UART.h"
  17          #include "DataAccess.h"
  18          
  19          
  20          
  21          // Control:
  22          unsigned char    // gb: Global
  23              //gb_wm = 1,   // working mode
  24              //gb_temp[2],  // temperature
  25              //gb_hum[2],   // humidity
  26              //gb_d1on[2],  // device 1 turn on at
  27              //gb_d1off[2], // device 1 turn off at
  28              //db_d2on[2],  // device 2 turn on at
  29              //gb_d2off[2], // device 2 turn off at
  30              buf2[] = {0, 0},     // buffer size 2
  31              //buf4[4],     // buffer size 4
  32              //buf5[5],     // buffer size 5
  33              buf16[16],   // buffer size 16, e.g.: for LCD, uart...
  34              gb_i = 0;    // multi purposes, reset before using
  35          int i = 0, ms0 = 4, ms1 = 100, ms2 = 200;
  36          // include other libraries that need to use above defined variables
  37          
  38          //#include "dht11.h"
  39          #include "LCD16x2_DHT11.h"
  40          
  41          // void set_sample_data()
  42          // {
  43          //  DA_SetDevice1TurnOnAt("06");
  44          //  DA_SetDevice1TurnOffAt("01");
  45          //   DA_SetDevice1State("0");
  46          
  47          //   DA_SetDevice2TurnOnAt("15");
  48          //   DA_SetDevice2TurnOffAt("50");  
  49          //   DA_SetDevice2State("0");
  50          
  51          //  DA_SetTemperature("05");
  52          //  DA_SetHumidity("35"); 
  53          // }
  54          
C51 COMPILER V9.60.7.0   MAIN                                                              10/16/2024 14:08:23 PAGE 2   

  55          void send_metrics(void)
  56          {
  57   1        char sh[2] = {'\0', '\0'};
  58   1        char st[2] = {'\0', '\0'};
  59   1      
  60   1        // send humidity
  61   1        Delay_ms(ms0);
  62   1        //strrst(buf2, 2);
  63   1        DA_GetHumidity(sh); // retrieve data from eeprom
  64   1        UART_Init();
  65   1        UART_TxStr("003:", 4); // not work on kit
  66   1        UART_TxString(sh); // hard code for testing
  67   1        Delay_ms(ms0);
  68   1      
  69   1        //Delay_ms(ms1);
  70   1      
  71   1        // send temperature
  72   1        //Delay_ms(ms2);
  73   1        strrst(st, 2);
  74   1        DA_GetTemperature(st); // retrieve data from eeprom
  75   1        Delay_ms(ms1);
  76   1        UART_Init();
  77   1        UART_TxStr("004:", 4); // not work on kit
  78   1        UART_TxString(st); // hard code for testing
  79   1        //Delay_ms(ms0);
  80   1      
  81   1        // lcd for testing
  82   1        clearLine(0);
  83   1        displayText("Mem-Hum:");
  84   1        DA_GetHumidity(buf2);
  85   1        displayText(buf2);
  86   1        clearLine(1);
  87   1        displayText("Mem-Tem:");
  88   1        DA_GetTemperature(buf2);
  89   1        displayText(buf2);
  90   1        Delay_ms(ms2);
  91   1      
  92   1        Delay_ms(ms1);
  93   1      }
  94          
  95          void init(void)
  96          {
  97   1        volatile unsigned char wm = '1'; // default: auto
  98   1        LED1 = 0;
  99   1        LED2 = 0;
 100   1      
 101   1        // LCD
 102   1        initLCD();
 103   1        
 104   1        // Welcome
 105   1        setCursor(0, 0);
 106   1        displayText("Starting...");
 107   1        
 108   1        // Data Access
 109   1        setCursor(0, 1);
 110   1        displayText("Data: ");
 111   1        EepromEraseAll();
 112   1        DA_Init();
 113   1        displayText("ok");
 114   1        
 115   1        Delay_ms(ms2);
 116   1        clearLine(1);
C51 COMPILER V9.60.7.0   MAIN                                                              10/16/2024 14:08:23 PAGE 3   

 117   1        
 118   1        // sample data for testing
 119   1        //set_sample_data();
 120   1        
 121   1        displayText("Mode: ");
 122   1        wm = DA_GetWorkingMode();
 123   1        switch(wm)
 124   1        {
 125   2        case '1':
 126   2          displayText("auto");
 127   2          break;
 128   2        case '0':
 129   2          displayText("manual");
 130   2          break;
 131   2        default:
 132   2          displayChar(wm);
 133   2          Delay_ms(8);
 134   2          displayText("NaN");
 135   2          break;
 136   2        }
 137   1      
 138   1        Delay_ms(ms2);
 139   1        clearLine(1);
 140   1        
 141   1        // UART
 142   1        displayText("UART: ");
 143   1        UART_Init();
 144   1        //Ext_int_Init(); // enable uart serial interrupt
 145   1        //Timer0_Init();  // init timer 0
 146   1      
 147   1        //UART_TxString("hello uart 8051");
 148   1        displayText("hello-2!");
 149   1        
 150   1        Delay_ms(ms2 * 2);
 151   1      }
 152          
 153          void on_rx(unsigned char *prt)
 154          {
 155   1        unsigned char rxcmd[] = {0, 0, 0, 0};
 156   1        volatile char txs[6] = {0, 0, 0, 0, 0, 0};
 157   1        unsigned char wm = '0';
 158   1      
 159   1        strrst(rxcmd, 4);
 160   1        strc(rxcmd, prt, 4);
 161   1      
 162   1        clearLine(1);
 163   1        displayText(prt);
 164   1        if (strcmp(rxcmd, "001:") == 0)
 165   1        {
 166   2          LED2 = 1;
 167   2          // 001: set working mode
 168   2          
 169   2          // update to eeprom
 170   2          DA_SetWorkingMode(prt[4]);
 171   2          Delay_ms(4);
 172   2      
 173   2          // generate response content
 174   2          stradd(txs, "001:", 0, 4);
 175   2          txs[4] = DA_GetWorkingMode();
 176   2          Delay_ms(4);
 177   2      
 178   2          // response to uart for confirmation
C51 COMPILER V9.60.7.0   MAIN                                                              10/16/2024 14:08:23 PAGE 4   

 179   2          UART_Init();
 180   2          UART_TxString(txs);
 181   2        }
 182   1        else if (strcmp(rxcmd, "002:") == 0)
 183   1        {
 184   2          LED2 = 1;
 185   2          // 002: get working mode
 186   2      
 187   2          // generate response content
 188   2          stradd(txs, "002:", 0, 4);
 189   2          txs[4] = DA_GetWorkingMode();
 190   2          Delay_ms(ms0);
 191   2      
 192   2          // send to uart for confirmation
 193   2          UART_Init();
 194   2          UART_TxString(txs);
 195   2        }
 196   1        else if (strcmp(rxcmd, "005:") == 0)
 197   1        {
 198   2          // 005: setDevice1OnAt
 199   2          LED2 = 1;
 200   2          strrst(buf2, 2);
 201   2          getRxVal(prt, buf2, 2);
 202   2          DA_SetDevice1TurnOnAt(buf2);
 203   2          Delay_ms(ms0);
 204   2      
 205   2          // generate response content
 206   2          strrst(buf2, 2);
 207   2          DA_GetDevice1TurnOnAt(buf2);
 208   2          Delay_ms(ms0);
 209   2      
 210   2          // response to uart
 211   2          UART_Init();
 212   2          UART_TxStr("005:", 4);
 213   2          UART_TxString(buf2);
 214   2        }
 215   1        else if (strcmp(rxcmd, "006:") == 0)
 216   1        {
 217   2          // 006: getDevice1OnAt
 218   2          LED2 = 1;
 219   2          // generate response content
 220   2          strrst(buf2, 2);
 221   2          DA_GetDevice1TurnOnAt(buf2);
 222   2          Delay_ms(ms0);
 223   2      
 224   2          // response to uart
 225   2          UART_Init();
 226   2          UART_TxStr("006:", 4);
 227   2          UART_TxString(buf2);
 228   2        }
 229   1        else if (strcmp(rxcmd, "007:") == 0)
 230   1        {
 231   2          // 007: setDevice1OffAt
 232   2          LED2 = 1;
 233   2          strrst(buf2, 2);
 234   2          getRxVal(prt, buf2, 2);
 235   2          DA_SetDevice1TurnOffAt(buf2);
 236   2          Delay_ms(ms0);
 237   2      
 238   2          // generate response content
 239   2          strrst(buf2, 2);
 240   2          DA_GetDevice1TurnOffAt(buf2);
C51 COMPILER V9.60.7.0   MAIN                                                              10/16/2024 14:08:23 PAGE 5   

 241   2          Delay_ms(ms0);
 242   2      
 243   2          // response to uart
 244   2          UART_Init();
 245   2          UART_TxStr("007:", 4);
 246   2          UART_TxString(buf2);
 247   2        }
 248   1        else if (strcmp(rxcmd, "008:") == 0)
 249   1        {
 250   2          // 008: getDevice1OffAt
 251   2          LED2 = 1;
 252   2          // generate response content
 253   2          strrst(buf2, 2);
 254   2          DA_GetDevice1TurnOffAt(buf2);
 255   2          Delay_ms(ms0);
 256   2      
 257   2          // response to uart
 258   2          UART_Init();
 259   2          UART_TxStr("008:", 4);
 260   2          UART_TxString(buf2);
 261   2        }
 262   1        else if (strcmp(rxcmd, "009:") == 0)
 263   1        {
 264   2          // 009: setDevice2OnAt
 265   2          LED2 = 1;
 266   2          strrst(buf2, 2);
 267   2          getRxVal(prt, buf2, 2);
 268   2          DA_SetDevice2TurnOnAt(buf2);
 269   2          Delay_ms(ms0);
 270   2      
 271   2          // generate response content
 272   2          strrst(buf2, 2);
 273   2          DA_GetDevice2TurnOnAt(buf2);
 274   2          Delay_ms(ms0);
 275   2      
 276   2          // response to uart
 277   2          UART_Init();
 278   2          UART_TxStr("009:", 4);
 279   2          UART_TxString(buf2);
 280   2        }
 281   1        else if (strcmp(rxcmd, "010:") == 0)
 282   1        {
 283   2          // 010: getDevice2OnAt
 284   2          LED2 = 1;
 285   2          // generate response content
 286   2          strrst(buf2, 2);
 287   2          DA_GetDevice2TurnOnAt(buf2);
 288   2          Delay_ms(ms0);
 289   2      
 290   2          // response to uart
 291   2          UART_Init();
 292   2          UART_TxStr("010:", 4);
 293   2          UART_TxString(buf2);
 294   2        }
 295   1        else if (strcmp(rxcmd, "011:") == 0)
 296   1        {
 297   2          // 011: setDevice2OffAt
 298   2          LED2 = 1;
 299   2          strrst(buf2, 2);
 300   2          getRxVal(prt, buf2, 2);
 301   2          DA_SetDevice2TurnOffAt(buf2);
 302   2          Delay_ms(ms0);
C51 COMPILER V9.60.7.0   MAIN                                                              10/16/2024 14:08:23 PAGE 6   

 303   2      
 304   2          // generate response content
 305   2          strrst(buf2, 2);
 306   2          DA_GetDevice2TurnOffAt(buf2);
 307   2          Delay_ms(ms0);
 308   2      
 309   2          // response to uart
 310   2          UART_Init();
 311   2          UART_TxStr("011:", 4);
 312   2          UART_TxString(buf2);
 313   2        }
 314   1        else if (strcmp(rxcmd, "012:") == 0)
 315   1        {
 316   2          // 012: getDevice2OffAt
 317   2          LED2 = 1;
 318   2          // generate response content
 319   2          strrst(buf2, 2);
 320   2          DA_GetDevice2TurnOffAt(buf2);
 321   2          Delay_ms(ms0);
 322   2      
 323   2          // response to uart
 324   2          UART_Init();
 325   2          UART_TxStr("012:", 4);
 326   2          UART_TxString(buf2);
 327   2        }
 328   1        else if (strcmp(rxcmd, "013:") == 0)
 329   1        {
 330   2          LED2 = 1;
 331   2          // 013: setDevice1State
 332   2          
 333   2          // update to eeprom
 334   2          DA_SetDevice1State(prt[4]);
 335   2          Delay_ms(4);
 336   2      
 337   2          // generate response content
 338   2          stradd(txs, "013:", 0, 4);
 339   2          txs[4] = DA_GetDevice1State();
 340   2          Delay_ms(4);
 341   2      
 342   2          // response to uart for confirmation
 343   2          UART_Init();
 344   2          UART_TxString(txs);
 345   2        }
 346   1        else if (strcmp(rxcmd, "014:") == 0)
 347   1        {
 348   2          LED2 = 1;
 349   2          // 014: getDevice1State
 350   2      
 351   2          // generate response content
 352   2          stradd(txs, "014:", 0, 4);
 353   2          txs[4] = DA_GetDevice1State();
 354   2          Delay_ms(ms0);
 355   2      
 356   2          // send to uart for confirmation
 357   2          UART_Init();
 358   2          UART_TxString(txs);
 359   2        }
 360   1        else if (strcmp(rxcmd, "015:") == 0)
 361   1        {
 362   2          LED2 = 1;
 363   2          // 015: setDevice2State
 364   2          
C51 COMPILER V9.60.7.0   MAIN                                                              10/16/2024 14:08:23 PAGE 7   

 365   2          // update to eeprom
 366   2          DA_SetDevice2State(prt[4]);
 367   2          Delay_ms(4);
 368   2      
 369   2          // generate response content
 370   2          stradd(txs, "015:", 0, 4);
 371   2          txs[4] = DA_GetDevice2State();
 372   2          Delay_ms(4);
 373   2      
 374   2          // response to uart for confirmation
 375   2          UART_Init();
 376   2          UART_TxString(txs);
 377   2        }
 378   1        else if (strcmp(rxcmd, "016:") == 0)
 379   1        {
 380   2          LED2 = 1;
 381   2          // 016: getDevice2State
 382   2      
 383   2          // generate response content
 384   2          stradd(txs, "016:", 0, 4);
 385   2          txs[4] = DA_GetDevice2State();
 386   2          Delay_ms(ms0);
 387   2      
 388   2          // send to uart for confirmation
 389   2          UART_Init();
 390   2          UART_TxString(txs);
 391   2        }
 392   1      
 393   1        Delay_ms(ms2); // to have enough time to see the LED turn on
 394   1        LED2 = 0;
 395   1        LED1 = 0;
 396   1        //clearLine(1);
 397   1      }
 398          
 399          void urx()
 400          {
 401   1        int icount = 0;
 402   1        LED1 = 0;
 403   1        LED2 = 0;
 404   1        
 405   1      
 406   1        clearLine(0);
 407   1        displayText("RX...");
 408   1        clearLine(1);
 409   1        
 410   1        while (icount < 7) // 7: we have 7 requests from thingsboards to get device's states
 411   1        {
 412   2          Delay_ms(ms1);
 413   2          strrst(buf16, 16);
 414   2          gb_i = 0;
 415   2          UART_Init();
 416   2          gb_i = UART_RXString(buf16);
 417   2          if (gb_i > 0)
 418   2          {
 419   3            LED1 = 1;
 420   3            on_rx(buf16);
 421   3            icount++;
 422   3          }
 423   2        }
 424   1      
 425   1        LED1 = 0;
 426   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              10/16/2024 14:08:23 PAGE 8   

 427          
 428          /*
 429          Flow:
 430            - 1. Refresh DHT11 sensor's data to eeprom
 431            - 2. Read current temperature & humidity data from eeprom and send it to 8266 via UART-TX
 432            - 3. Control devices base on eeprom data
 433            - 4. UART-RX and proceed command if data is available
 434          */
 435          void loop(void)
 436          {
 437   1        LED1 = 0;
 438   1        //strrst(buf16, 16);
 439   1        //char buf2[2];
 440   1        // 1. Refresh DHT11 sensor's data to eeprom
 441   1        Dht_Update();
 442   1      
 443   1        // 2.1 Read temperature/humidity
 444   1        send_metrics();
 445   1        Delay_ms(ms0);
 446   1        
 447   1        //UART-RX and proceed command if data is available
 448   1        urx();
 449   1        
 450   1        Delay_ms(ms2);
 451   1      }
 452          
 453          
 454          
 455          void main(void)
 456          {
 457   1        init();
 458   1        while(1)
 459   1        {
 460   2          loop(); 
 461   2        }
 462   1      }
*** WARNING C316 IN LINE 462 OF main.c: unterminated conditionals


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4067    ----
   CONSTANT SIZE    =    270    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     53     136
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
